-- -- Lab 8
-- -- Part 1

-- -- Create tables
--  CREATE TABLE departments (
--     dept_id INT PRIMARY KEY,
--     dept_name VARCHAR(50),
--     location VARCHAR(50)
--  );
--  CREATE TABLE employees (
--     emp_id INT PRIMARY KEY,
--     emp_name VARCHAR(100),
--     dept_id INT,
--     salary DECIMAL(10,2),
--  FOREIGN KEY (dept_id) REFERENCES departments(dept_id)
--  );
--  CREATE TABLE projects (
--     proj_id INT PRIMARY KEY,
--     proj_name VARCHAR(100),
--     budget DECIMAL(12,2),
--     dept_id INT,
--  FOREIGN KEY (dept_id) REFERENCES departments(dept_id)
--  );-- Insert sample data
--  INSERT INTO departments VALUES 
-- (101, 'IT', 'Building A'),
--  (102, 'HR', 'Building B'),
--  (103, 'Operations', 'Building C');
--  INSERT INTO employees VALUES
--  (1, 'John Smith', 101, 50000),
--  (2, 'Jane Doe', 101, 55000),
--  (3, 'Mike Johnson', 102, 48000),
--  (4, 'Sarah Williams', 102, 52000),
--  (5, 'Tom Brown', 103, 60000);
--  INSERT INTO projects VALUES
--  (201, 'Website Redesign', 75000, 101),
--  (202, 'Database Migration', 120000, 101),
--  (203, 'HR System Upgrade', 50000, 102);


-- -- Part 2
-- -- 2.1
-- CREATE INDEX emp_salary_idx ON employees(salary);

-- SELECT indexname, indexdef 
-- FROM pg_indexes 
-- WHERE tablename = 'employees';

-- 2 first is the unique index that is a primary key and the second is the index I just created

-- -- 2.2
-- CREATE INDEX emp_dept_idx ON employees(dept_id);
-- SELECT * FROM employees WHERE dept_id = 101;
-- it doesn't iterate through the entire list of rows and optimize retrieval

-- -- 2.3
-- SELECT 
--     tablename,
--     indexname,
--     indexdef
--  FROM pg_indexes
--  WHERE schemaname = 'public'
--  ORDER BY tablename, indexname;
-- I only created 2, but had 14 indexes as a result. This is because primary key is an index itself 
-- and created automatically

-- -- Part 3
-- -- 3.1
-- CREATE INDEX emp_dept_salary_idx ON employees(dept_id, salary);
-- SELECT emp_name, salary 
-- FROM employees 
-- WHERE dept_id = 101 AND salary > 52000;

-- No, because index orders by dept_id and then by salary, just filtering salary won't 
-- take andavtage of the index.

-- -- 3.2
-- CREATE INDEX emp_salary_dept_idx ON employees(salary, dept_id);
-- SELECT * FROM employees WHERE dept_id = 102 AND salary > 50000;
-- SELECT * FROM employees WHERE salary > 50000 AND dept_id = 102;

-- Yes, that matters. The index is sorted by salary and within that by dept_id. 
-- The first query filters the output first by the salary so the second one is more efficient


-- -- Part 4
-- -- 4.1
-- ALTER TABLE employees ADD COLUMN email VARCHAR(100);
--  UPDATE employees SET email = 'john.smith@company.com' WHERE emp_id = 1;
--  UPDATE employees SET email = 'jane.doe@company.com' WHERE emp_id = 2;
--  UPDATE employees SET email = 'mike.johnson@company.com' WHERE emp_id = 3;
--  UPDATE employees SET email = 'sarah.williams@company.com' WHERE emp_id = 4;
--  UPDATE employees SET email = 'tom.brown@company.com' WHERE emp_id = 5;

-- CREATE UNIQUE INDEX emp_email_unique_idx ON employees(email);

-- INSERT INTO employees (emp_id, emp_name, dept_id, salary, email)
--  VALUES (6, 'New Employee', 101, 55000, 'john.smith@company.com');
-- Duplicate rows contradict the properties of the index 


-- -- 4.2
-- ALTER TABLE employees ADD COLUMN phone VARCHAR(20) UNIQUE;
-- SELECT indexname, indexdef 
-- FROM pg_indexes 
-- WHERE tablename = 'employees' AND indexname LIKE '%phone%';

-- Yes, unoque constraint automatically creates a unique b tree index


-- -- Part 5
-- -- 5.1
-- CREATE INDEX emp_salary_desc_idx ON employees(salary DESC);
--  SELECT emp_name, salary 
-- FROM employees 
-- ORDER BY salary DESC;
-- The query won't take time to sort the result, it's already sorted by the index
-- It is just a perfect match query for the index.

-- -- 5.2
-- CREATE INDEX proj_budget_nulls_first_idx ON projects(budget NULLS FIRST);

-- SELECT project_name, budget 
-- FROM projects 
-- ORDER BY budget NULLS FIRST;
