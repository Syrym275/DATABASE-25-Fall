-- -- Part 6
-- -- 6.1
-- CREATE INDEX emp_name_lower_idx ON employees(LOWER(emp_name));
-- SELECT * FROM employees WHERE LOWER(emp_name) = 'john smith';
-- It would iterate through and convert every name to lowercase 
-- but with the index it just searches for it in the sorted lowercase names and return it faster

-- -- 6.2
-- ALTER TABLE employees ADD COLUMN hire_date DATE;
--  UPDATE employees SET hire_date = '2020-01-15' WHERE emp_id = 1;
--  UPDATE employees SET hire_date = '2019-06-20' WHERE emp_id = 2;
--  UPDATE employees SET hire_date = '2021-03-10' WHERE emp_id = 3;
--  UPDATE employees SET hire_date = '2020-11-05' WHERE emp_id = 4;
--  UPDATE employees SET hire_date = '2018-08-25' WHERE emp_id = 5;

-- CREATE INDEX emp_hire_year_idx ON employees(EXTRACT(YEAR FROM hire_date));
-- SELECT emp_name, hire_date 
-- FROM employees 
-- WHERE EXTRACT(YEAR FROM hire_date) = 2020;



-- -- Part 7
-- -- 7.1
-- ALTER INDEX emp_salary_idx RENAME TO employees_salary_index;
-- SELECT indexname FROM pg_indexes WHERE tablename = 'employees';

-- 7.2
-- DROP INDEX emp_salary_dept_idx;
-- If it's never used, its creation takes some time and it's inefficient
-- Also they make insert, update, delete slower because the indexes are updated as well
-- Also indexes take storage

-- -- 7.3
--  REINDEX INDEX employees_salary_index;


-- -- Part 8
-- -- 8.1
 -- SELECT e.emp_name, e.salary, d.dept_name
 -- FROM employees e
 -- JOIN departments d ON e.dept_id = d.dept_id
 -- WHERE e.salary > 50000
 -- ORDER BY e.salary DESC;

-- -- 8.2
-- CREATE INDEX emp_salary_filter_idx ON employees(salary) WHERE salary > 50000;
-- CREATE INDEX proj_high_budget_idx ON projects(budget) 
-- WHERE budget > 80000;

--  SELECT project_name, budget 
-- FROM projects 
-- WHERE budget > 80000;
-- faster to scan, less memory and time
-- sometimes we dont need the entire column we only need a part of it

-- -- 8.3
-- EXPLAIN SELECT * FROM employees WHERE salary > 52000;
-- -- Sequential scan is shown, the database ignored the index and scanned the entire table row by row
-- -- because the where clause doen't match the index entirely


-- -- Part 9
-- -- 9.1
-- CREATE INDEX dept_name_hash_idx ON departments USING HASH (dept_name);
-- SELECT * FROM departments WHERE dept_name = 'IT';
-- Hash handles quality comparisons better witha constant time retrieval

-- -- 9.2
-- CREATE INDEX proj_name_btree_idx ON projects(project_name);
--  CREATE INDEX proj_name_hash_idx ON projects USING HASH (project_name);
 
-- SELECT * FROM projects WHERE project_name = 'Website Redesign';
-- SELECT * FROM projects WHERE project_name > 'Database';


-- -- Part 10
-- -- 10.1
-- SELECT 
--     schemaname,
--     tablename,
--     indexname,
--     pg_size_pretty(pg_relation_size(format('%I.%I', schemaname, indexname)::regclass))
--         AS index_size
-- FROM pg_indexes
-- WHERE schemaname = 'public'
-- ORDER BY tablename, indexname;

-- dept_name_hash_idx and proj_name_hash_idx
-- because varchar columns take more space than for example int columns and there are more rows
-- hash actually takes less size


-- -- 10.2
-- DROP INDEX IF EXISTS proj_name_hash_idx;

-- -- 10.3
--  CREATE VIEW index_documentation AS
--  SELECT 
--     tablename,
--     indexname,
--     indexdef,
--  'Improves salary-based queries' as purpose
--  FROM pg_indexes
--  WHERE schemaname = 'public' 
-- AND indexname LIKE '%salary%';
-- SELECT * FROM index_documentation;

/*
Summary questions
1) B - tree
2)
column filtering
joining
sorting order by
3)
where there are only couple values to a column
(like gender or boolean)
small tables
4) it slows down because the index is being modified as well
5) use EXPLAIN function or EXPLAIN ANALYZE
